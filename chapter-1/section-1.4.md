# Chapter 1: 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.4 클로저
- 함수형 프로그래밍의 패러다임을 이해하려면 클로저에 대해 반드시 알아야 한다.(필요성)

### 1.4.1 클로저의 정의
- 클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합
\* 선언된 어휘적 환경 : 변수가 코드 내부 어디에서 선언됐는지를 말하는 것
- 훅이 등장한 16.8 버전을 기점으로, 클로저 개념이 적극적 사용 되기 시작
- 코드가 작성된 순간에 정적으로 결정
\+ 호출방식에 따라 동적으로 결정되는 this 와 다르다.

### 1.4.2 변수의 유효 범위, 스코프
- 변수의 유효 범위에 따라서 어휘적 환경이 결정된다.
\* 스코프(scope) : 변수의 유효 범위
#### 1. 전역 스코프(global scope)
- 전역 레벨에서 선언하는 것
\+ 브라우저 환경에서 전역 객체 : window
\+ Node.js환경 : gloval
#### 2. 함수 스코프
- 다른언어와 달리 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. 즉, {} 블록이 스코프 범위를 경정하지 않는다.

### 1.4.3 클로저의 활용
- 선언된 함수 레벨 스코프를 활용해 어떤 작업을 할 수 있다는 개념이 바로 "클로저"
#### 1. 클로저의 활용
- 전역스코프 : 어디서든 원하는 값 꺼내 올 수 있다 = 반대로 누구든 접근 및 수정 할 수 있다
- 클로저의 개념을 활용하면 전역 스코프의 무분별한 사용을 막고, 개발자가 원하는 방향으로 노출 시킬 수 있다
#### 2. 리액트에서의 클로저
- useState
<details>
<summary>예제</summary>
function Component() {
    const [state, useState] = useState()

    function hadleClick() {
        // useState 호출은 위에서 끝났지만,
        // setState는 계속 내부의 최신값(prev)을 알고 있다.
        // 이는 클로저를 활용했기 때문에 가능하다
        setState((prev) => prev + 1)
    }
}
</details>

- 최신값 확인 How ? 클로저가 useState 내부에서 활용됐기 때문
- 외부 함수(useState)가 반환한 내부 함수(setState)는 외부함수 호출이 끝났어도,
자신이 선언된(저장 어딘가)곳을 기억하기때문에 state 값을 사용할 수 있다.

### 1.4.4 주의할 점
- var는 for문의 존재와 상관없이 해당 구문이 선언된 함수 레벨 스코프를 바라보고 있다,
함수 내부 실행이 아니면 전역 스코프에 var i가 등록되어 있다
- let은 기본적으로 블록 레벨 스코프를 가지게 되므로 let i가 for문을 순회하면서 각각의 스코프를 갖게된다.
setTimeout이 실행되는 시점에도 유효해서 각 콜백이 의도한 i 값을 바라본다.
\+ 66page 함수 참고
- 클로저의 개념, 즉 외부 함수를 기억하고, 이를 내부함수에서 가져다 쓰는 매커니즘은 성능에 영향미친다
꼭 필요한 작업이 아닌경우, 클로저 사용시 주의가 필요 = 클로저 사용은 적절한 스코프로 가둬두지 않는다면 성능에 악역향 미친다.(결론)

### 1.4.5 정리
- 부수 효과가 없고 순수해야 한다는 목적을 달성하기 위해 적극적으로 사용되는 개념이다.