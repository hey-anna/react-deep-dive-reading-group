# 주한

### 리액트 개발을 위해 꼭 알아야 할 JavaScript

- 리액트 코드 기반이 되는 JavaScript
- 웹 애플리케이션이 작동하도록 리액트가 수행하는 작업을 이해하기 위해서는 JavaScript를 짚어볼 필요가 있다.

<br/>

---

### JavaScript의 동등 비교: 의존성 배열?

- 리액트에서 함수형 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열을 자주 보게 된다.

<br/>

---

### 의존성 배열

- `useEffect`, `useCallback`, `useMemo`와 같은 훅을 사용할 때 두 번째 인수로 전달되는 배열.
- 이 배열에는 특정 값들이 포함되며 해당 값들 변경될 때마다 해당 훅이 다시 실행되도록 설정하는 역할을 한다.

```jsx
useEffect(() => {
  console.log("의존성 요소 1 혹은 2가 바뀌었습니다.");
}, [의존성1, 의존성2]);
```

- 훅 실행 시점을 효율적으로 제어할 수 있도록 돕는다, 이를 올바르게 설정하지 않으면 불필요하게 훅이 반복 실행되거나 반대로 필요한 시점에 훅이 실행되지 않을 수도 있다.
  - 빈 배열: 훅이 한 번만 실행, 초기화 작업 혹은 한 번만 실행될 때 사용
  - 특정 값들 포함한 배열: 배열에 포함된 값들이 변경될 때만 훅이 다시 실행
  - 의존성 배열을 생략?: 매번 렌더링 될 때마다 훅이 실행, 권장되지 않는 방법이며 무한 루프나 성능 문제 생길 수 있음

<br/>

---

### 설정에 따라서

- eslint-react-config에 선언돼 있는 react-hooks/exhaustive-deps의 도움을 받아 해당 배열을 채울 수도 있다

<br/>

---

### ESLint와 eslint-plugin-react-hooks

- ESLint는 코드 스타일 문제 자동 감지, 개발자에게 개선 권장하는 도구.
- 리액트 프로젝트에서는 eslint-plugin-react-hooks 플러그인이 자주 사용되며 리액트 훅을 올바르게 사용했는지 확인해주는 규칙들을 제공한다.
- react-hooks/exhaustive-deps 규칙은 해당 플러그인에 포함된 규칙 중 하나고 hooks에서 의존성 배열을 정확하게 관리하도록 돕는다.
  - 의존성 누락 감지: 의존성 배열에 누락된 변수가 있다면 이를 감지하고 경고를 발생시킴
  - 자동 수정 제안: ESLint는 의존성 자동 감지 뿐 아니라 자동 추가 기능도 제공한다.
  - 어떤 값 포함해야 하는지 헷갈릴 수 있는데 이때 의존성을 추천 받을 수 있다.

```jsx
useEffect(() => {
  fetchData(someProp); // someProp 사용
}, []); // 이 배열이 빈 경우, someProp이 변경되더라도 useEffect는 실행되지 않는 게 맞다. 그러면 본문에서 파라미터는 왜 넣는 거지?
```

- someProp이 의존성 배열에 포함되지 않았다 → someProp이 변경되어도 useEffect는 실행되지 않는 문제가 발생할 수 있다
  - 해당 규칙이 이를 감지해서 경고를 띄우고 제안하는 걸 뜻함

<br/>

---

### 실제 react-hooks/exhaustive-deps 사용 케이스

- 한 번만 실행됐으면 좋겠다
  - 의존성 배열을 빈 배열로 설정
  - 컴포넌트 마운트 때만 실행, 이후에는 의존성 배열 변화가 없다, 재실행 X

```jsx
useEffect(() => {
  // 초기화 코드, 예를 들어 API 호출
  fetchInitialData();
}, []); // 빈 배열을 통해 최초 마운트 시에만 실행
```

- 규칙과 상호작용
  - 규칙은 useEffect 등 의존성 배열 가진 훅 내부에서 사용할 모든 변수를 의존성 배열에 포함시키도록 권장
  - 만약 위 코드에서 초기 데이터 호출 함수가 외부에서 정의되었고 의존성 배열에 포함되지 않았다면 경고 발생 가능

```jsx
const fetchInitialData = () => {
  // 데이터를 가져오는 함수
};

useEffect(() => {
  fetchInitialData(); // ESLint가 경고를 줄 수 있음
}, []);
```

- 규칙에 의해 함수를 의존성 배열에 추가하라 제안할 수 있다

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]); // 제안된 수정 사항
```

- 규칙을 무시해도 될 때 → ESLint 경고를 무시하면 됨
  - 굳이 규칙을 준수하지 않아도 된다면
  - 함수가 변경되더라도 useEffect가 다시 실행될 필요 없는 경우
  - 혹은 초기화 시 한 번만 실행되길 원한다면

```jsx
useEffect(() => {
  fetchInitialData(); // 초기화 작업
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---

### 함수도 의존성 배열에 포함될 수 있는 배경

- 리액트에서 컴포넌트는 함수형 컴포넌트로 작성되는 경우 많다
- 컴포넌트 안에서 함수들이 정의
- useEffect에서 함수들을 호출할 수 있음
  - 그런데 함수 자체도 의존성 배열에 포함될 수 있다

<br/>

---

### 리액트 훅과 함수 관계

- 리액트 컴포넌트는 상태(state)나 props 변경마다 리렌더링

> - 이 과정에서 컴포넌트 내 모든 함수도 재정의되기 때문
> - 리액트는 함수 참조가 변경될 수 있다 판단해서 의존성 배열에 포함시키도록 권장하기도 한다.

```jsx
const MyComponent = () => {
  const fetchInitialData = () => {
    // 데이터 가져오는 함수
  };

  useEffect(() => {
    fetchInitialData();
  }, []);
};
```

- 위 코드에서 사실 fetchInitialData 함수는 컴포넌트 리렌더링마다 새로 정의되는 것과 같음
- 따라서 규칙이 의존성 배열에 함수를 포함하라 경고를 줄 수 있음
  - 리액트 생각 1 : 컴포넌트가 리렌더링될텐데, 그럼 함수도 새로 쓰이는 거랑 다름 없어서 변경될 수 있잖아?
  - 리액트 생각 2: 그럼 의존성 배열에 포함시켜야 useEffect 같은 의존성 기반 훅이 잘 작동하겠네?

<br/>

---

### 함수가 의존성 배열에 포함될 때

- 함수를 의존성 배열에 포함시키는 것은 리액트가 해당 함수 참조 변경마다 useEffect를 재실행하게 만드는 방법

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]);
```

- 위와 같은 코드에서는 함수 변경(== 리렌더링)마다 useEffect가 다시 실행

> - 리액트에서는 함수도 값과 마찬가지로 변경될 수 있는 상태로 간주, 이 경우를 대비해 의존성 배열에 포함시킨다.

<br/>

---

### 의도적으로 빈 배열을 사용해야 하는 경우

- 함수를 매번 재정의하더라도 useEffect를 한 번만 실행하고 싶다면 빈 배열 유지 혹은 useCallback을 사용해서 fetchInitialData를 메모이제이션(값을 캐시)할 수 있음.

```jsx
const fetchInitialData = useCallback(() => {
  // 데이터 가져오는 함수
}, []); // 의존성 배열이 빈 배열이므로, 함수가 재정의되지 않음

useEffect(() => {
  fetchInitialData();
}, []);
```

```jsx
useEffect(() => {
  fetchInitialData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---

### 함수의 메모이제이션?

- 위 맥락에서는 함수를 메모이제이션 한다는 상황으로 쓰임
- 함수가 재정의되지 않도록 해당 함수의 참조를 유지하는 걸 의미
  - 리렌더링마다 함수가 불필요하게 다시 생성되는 걸 방지

<br/>

---

### 메모이제이션?

> - 컴퓨터 과학에서 자주 사용하는 기법, 이전 계산 결과를 캐시에 저장
>
> 동일한 입력이 다시 주어지면 캐시된 결과를 반환하여 불필요한 계산을 피하는 방법
>
> 함수나 값의 참조를 유지하는 데 활용

<br/>

---

### useCallback 사용한 함수 메모이제이션

- useCallback 훅을 사용하면 특정 의존성 변경되지 않는 한 함수 참조가 유지
  - 리렌더링 때에도 의존성 변경되지 않는 한 동일한 함수가 계속해서 사용

```jsx
const MyComponent = () => {
  const fetchInitialData = useCallback(() => {
    // 데이터를 가져오는 함수
    console.log("Fetching data...");
  }, []); // 빈 배열을 의존성으로 전달하여 함수 참조 유지

  useEffect(() => {
    fetchInitialData();
  }, [fetchInitialData]); // 이제 useEffect는 fetchInitialData가 변경될 때만 실행됨

  return <div>My Component</div>;
};
```

- useCallback을 사용해서 의존성 배열에 전달된 값이 변경되지 않는 한 메모이제이션 되게 한 케이스
  - 이 경우 의존성 빈 배열, 컴포넌트 첫 렌더링 때만 한 번 생성됐다가 이후에는 새로운 함수 안 생김
  - fetchInitialData를 의존성으로 추가해도 함수는 변경되지 않아서 useEffect는 처음 한 번만 실행

<br/>

---

### 왜 메모이제이션이 중요할까?

- 컴포넌트가 상태 변화나 부모 컴포넌트 리렌더링으로 인해 여러 번 렌더링 될 수 있어서
  - 매번 렌더링마다 내부에서 정의된 함수가 새롭게 정의되면?
  - 불필요한 연산이 늘거나 useEffect 등 훅이 불필요하게 재실행될 수 있음
- 메모이제이션을 통해 함수 참조를 유지하면 해당 문제를 피할 수 있다.

<br>

---

### 해당 함수의 참조를 유지한다?

> - JavaScript에서 함수는 일급 객체(first-class object)

- 이는 함수가 변수에 할당될 수 있고
- 다른 함수의 인자로 전달될 수 있으며
- 반환 값으로도 사용될 수 있는 것

```jsx
const result = greeting('name');

const searchUser = (getUser(user)) => {

};

const getImg = () => {
	return accessImg();
}
```

```jsx
const myFunction = () => {
  console.log("Hello, world!");
};
```

- 위에서 식별자는 함수에 대한 참조를 가진다
  - 이 참조는 해당 함수가 메모리에 있는 위치를 가르킨다

<br>

---

### 리액트에서의 함수 참조와 렌더링

- 리액트 컴포넌트는 상태 변경되거나 부모 컴포넌트 렌더링 될 때마다 리렌더링
  - 컴포넌트 내부 정의된 모든 변수와 함수도 다시 정의되어버림

```jsx
const MyComponent = () => {
  const handleClick = () => {
    console.log("Button clicked!");
  };

  return <button onClick={handleClick}>Click me</button>;
};
```

- 이벤트 핸들러가 리렌더링마다 새롭게 정의되는 걸 뜻함

<br>

---

### useCallback과 함수 참조 유지

- 리액트에서 useCallback 훅을 사용해서 특정 의존성 변경되지 않는 한 함수의 참조를 동일하게 유지 가능
  - 리렌더링 발생해도 동일한 함수 참조를 사용

```jsx
const MyComponent = () => {
  const handleClick = useCallback(() => {
    console.log("Button clicked!");
  }, []); // 빈 배열이므로, 함수 참조는 처음 한 번만 생성됨

  return <button onClick={handleClick}>Click me</button>;
};
```

- 이벤트 핸들러가 처음 렌더링 때만 정의되었다가 이후에는 새로운 참조가 생기지 않는다
  - 내부적으로 이전에 생성된 함수의 참조를 그대로 사용하니까

<br>

---

### 왜 참조를 유지하는 게 중요할까?

- 성능 최적화
  - 불필요한 함수 재생성이 없으니까
- 불필요한 훅 실행 방지
  - useEffect 훅은 의존성 배열에 함수도 포함할 수 있다
  - 이때 대상 함수가 useCallback 등을 통해 함수 참조가 유지된다면 해당 의존성이 변하지 않는 한 useEffect에서의 변경도 없음
  - 따라서 훅이 불필요하게 실행되는 걸 방지
- 안정성 향상
  - 참조가 변경되지 않으면 함수가 참조하는 상태나 값들이 예상치 못하게 변경되는 일을 막을 수 있다

<br>

---

### 렌더링 관점

- 렌더링이 일어나는 이유
  - state, props 등 동등 비교에 따른 결과이기 때문
- props의 동등 비교?
  - 객체의 얕은 비교를 기반으로 이루어짐

<br>

---

### 얕은 비교란?

- 객체 최상위 속성들만 비교하는 방식
  - 아래처럼 JS는 객체의 참조만을 비교하며 이를 얕은 비교라고 함

```jsx
const obj1 = { name: "Alice", age: 25 };
const obj2 = { name: "Alice", age: 25 };
const obj3 = obj1;

console.log(obj1 === obj2); // false
// 왜? 단순히 내용이 같은 게 아니라, 새롭게 쓰여졌기 때문
console.log(obj1 === obj3); // true
// 왜? 단순히 내용이 같은 것 뿐만 아니라 obj1과 같은 객체를 참조하기 때문에
```

<br>

---

### 리액트에서의 얕은 비교

> 성능 최적화를 위한 중요 메커니즘
>
> 컴포넌트 props나 state가 변경되었는지 확인하기 위해 얕은 비교 사용

- props의 얕은 비교
  - 부모 컴포넌트 → 자식 컴포넌트에 props 전달할 때 리액트는 새로운 props 객체와 이전 props 객체를 얕게 비교
  - 어떤 속성도 변경되지 않았다면 자식 컴포넌트를 다시 렌더링할 필요 없다 판단
- state의 얕은 비교
  - 컴포넌트 내에서 state 변경할 때 리액트는 새로운 상태 객체와 이전 상태 객체를 얕게 비교
  - 상태 객체가 동일하다면 컴포넌트 리렌더링 안함

<br>

---

### 얕은 비교 예제

```jsx
const MyComponent = React.memo(({ data }) => {
  console.log("MyComponent rendered");
  return <div>{data.name}</div>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = { name: "Alice" };

  return (
    <>
      <MyComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
};
```

- React.memo로 감싸진 컴포넌트
  - 컴포넌트 props가 변경되지 않으면 다시 렌더링되지 않도록 하는 의도
  - 그런데 data가 항상 새로운 객체로 생성된다면?
  - 얕은 비교에 의해 MyComponent는 매번 리렌더링
  - 문제 해결을 위해서는 data 객체를 메모이제이션 해야 함

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = useMemo(() => ({ name: "Alice" }), []); // 데이터 객체를 메모이제이션

  return (
    <>
      <MyComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
};
```

- 위와 같이 정의하면 data 객체는 처음 렌더링 때만 생성
- 이후 count 변경되어도 data 객체는 동일한 참조 유지
  - MyComponent는 리렌더링 되지 않는다

> 객체의 참조만을 비교하므로 동일한 참조를 유지하는 객체는 변경되지 않았다고 판단할 수 있게 된다
>
> 이를 이해하고 활용하면 불필요한 렌더링 줄이고 컴포넌트 성능 최적화 가능

<br>

---
