# 주한

### 리액트 개발을 위해 꼭 알아야 할 JavaScript

- 리액트 코드 기반이 되는 JavaScript
- 웹 애플리케이션이 작동하도록 리액트가 수행하는 작업을 이해하기 위해서는 JavaScript를 짚어볼 필요가 있다.

<br/>

---

### JavaScript의 동등 비교: 의존성 배열?

- 리액트에서 함수형 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열을 자주 보게 된다.

<br/>

---

### 의존성 배열

- `useEffect`, `useCallback`, `useMemo`와 같은 훅을 사용할 때 두 번째 인수로 전달되는 배열.
- 이 배열에는 특정 값들이 포함되며 해당 값들 변경될 때마다 해당 훅이 다시 실행되도록 설정하는 역할을 한다.

```jsx
useEffect(() => {
  console.log("의존성 요소 1 혹은 2가 바뀌었습니다.");
}, [의존성1, 의존성2]);
```

- 훅 실행 시점을 효율적으로 제어할 수 있도록 돕는다, 이를 올바르게 설정하지 않으면 불필요하게 훅이 반복 실행되거나 반대로 필요한 시점에 훅이 실행되지 않을 수도 있다.
  - 빈 배열: 훅이 한 번만 실행, 초기화 작업 혹은 한 번만 실행될 때 사용
  - 특정 값들 포함한 배열: 배열에 포함된 값들이 변경될 때만 훅이 다시 실행
  - 의존성 배열을 생략?: 매번 렌더링 될 때마다 훅이 실행, 권장되지 않는 방법이며 무한 루프나 성능 문제 생길 수 있음

<br/>

---

### 설정에 따라서

- eslint-react-config에 선언돼 있는 react-hooks/exhaustive-deps의 도움을 받아 해당 배열을 채울 수도 있다

<br/>

---

### ESLint와 eslint-plugin-react-hooks

- ESLint는 코드 스타일 문제 자동 감지, 개발자에게 개선 권장하는 도구.
- 리액트 프로젝트에서는 eslint-plugin-react-hooks 플러그인이 자주 사용되며 리액트 훅을 올바르게 사용했는지 확인해주는 규칙들을 제공한다.
- react-hooks/exhaustive-deps 규칙은 해당 플러그인에 포함된 규칙 중 하나고 hooks에서 의존성 배열을 정확하게 관리하도록 돕는다.
  - 의존성 누락 감지: 의존성 배열에 누락된 변수가 있다면 이를 감지하고 경고를 발생시킴
  - 자동 수정 제안: ESLint는 의존성 자동 감지 뿐 아니라 자동 추가 기능도 제공한다.
  - 어떤 값 포함해야 하는지 헷갈릴 수 있는데 이때 의존성을 추천 받을 수 있다.

```jsx
useEffect(() => {
  fetchData(someProp); // someProp 사용
}, []); // 이 배열이 빈 경우, someProp이 변경되더라도 useEffect는 실행되지 않는 게 맞다. 그러면 본문에서 파라미터는 왜 넣는 거지?
```

- someProp이 의존성 배열에 포함되지 않았다 → someProp이 변경되어도 useEffect는 실행되지 않는 문제가 발생할 수 있다
  - 해당 규칙이 이를 감지해서 경고를 띄우고 제안하는 걸 뜻함

<br/>

---

### 실제 react-hooks/exhaustive-deps 사용 케이스

- 한 번만 실행됐으면 좋겠다
  - 의존성 배열을 빈 배열로 설정
  - 컴포넌트 마운트 때만 실행, 이후에는 의존성 배열 변화가 없다, 재실행 X

```jsx
useEffect(() => {
  // 초기화 코드, 예를 들어 API 호출
  fetchInitialData();
}, []); // 빈 배열을 통해 최초 마운트 시에만 실행
```

- 규칙과 상호작용
  - 규칙은 useEffect 등 의존성 배열 가진 훅 내부에서 사용할 모든 변수를 의존성 배열에 포함시키도록 권장
  - 만약 위 코드에서 초기 데이터 호출 함수가 외부에서 정의되었고 의존성 배열에 포함되지 않았다면 경고 발생 가능

```jsx
const fetchInitialData = () => {
  // 데이터를 가져오는 함수
};

useEffect(() => {
  fetchInitialData(); // ESLint가 경고를 줄 수 있음
}, []);
```

- 규칙에 의해 함수를 의존성 배열에 추가하라 제안할 수 있다

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]); // 제안된 수정 사항
```

- 규칙을 무시해도 될 때 → ESLint 경고를 무시하면 됨
  - 굳이 규칙을 준수하지 않아도 된다면
  - 함수가 변경되더라도 useEffect가 다시 실행될 필요 없는 경우
  - 혹은 초기화 시 한 번만 실행되길 원한다면

```jsx
useEffect(() => {
  fetchInitialData(); // 초기화 작업
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---

### 함수도 의존성 배열에 포함될 수 있는 배경

- 리액트에서 컴포넌트는 함수형 컴포넌트로 작성되는 경우 많다
- 컴포넌트 안에서 함수들이 정의
- useEffect에서 함수들을 호출할 수 있음
  - 그런데 함수 자체도 의존성 배열에 포함될 수 있다

<br/>

---

### 리액트 훅과 함수 관계

- 리액트 컴포넌트는 상태(state)나 props 변경마다 리렌더링

> - 이 과정에서 컴포넌트 내 모든 함수도 재정의되기 때문
> - 리액트는 함수 참조가 변경될 수 있다 판단해서 의존성 배열에 포함시키도록 권장하기도 한다.

```jsx
const MyComponent = () => {
  const fetchInitialData = () => {
    // 데이터 가져오는 함수
  };

  useEffect(() => {
    fetchInitialData();
  }, []);
};
```

- 위 코드에서 사실 fetchInitialData 함수는 컴포넌트 리렌더링마다 새로 정의되는 것과 같음
- 따라서 규칙이 의존성 배열에 함수를 포함하라 경고를 줄 수 있음
  - 리액트 생각 1 : 컴포넌트가 리렌더링될텐데, 그럼 함수도 새로 쓰이는 거랑 다름 없어서 변경될 수 있잖아?
  - 리액트 생각 2: 그럼 의존성 배열에 포함시켜야 useEffect 같은 의존성 기반 훅이 잘 작동하겠네?

<br/>

---

### 함수가 의존성 배열에 포함될 때

- 함수를 의존성 배열에 포함시키는 것은 리액트가 해당 함수 참조 변경마다 useEffect를 재실행하게 만드는 방법

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]);
```

- 위와 같은 코드에서는 함수 변경(== 리렌더링)마다 useEffect가 다시 실행

> - 리액트에서는 함수도 값과 마찬가지로 변경될 수 있는 상태로 간주, 이 경우를 대비해 의존성 배열에 포함시킨다.

<br/>

---

### 의도적으로 빈 배열을 사용해야 하는 경우

- 함수를 매번 재정의하더라도 useEffect를 한 번만 실행하고 싶다면 빈 배열 유지 혹은 useCallback을 사용해서 fetchInitialData를 메모이제이션(값을 캐시)할 수 있음.

```jsx
const fetchInitialData = useCallback(() => {
  // 데이터 가져오는 함수
}, []); // 의존성 배열이 빈 배열이므로, 함수가 재정의되지 않음

useEffect(() => {
  fetchInitialData();
}, []);
```

```jsx
useEffect(() => {
  fetchInitialData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---

### 함수의 메모이제이션?

- 위 맥락에서는 함수를 메모이제이션 한다는 상황으로 쓰임
- 함수가 재정의되지 않도록 해당 함수의 참조를 유지하는 걸 의미
  - 리렌더링마다 함수가 불필요하게 다시 생성되는 걸 방지

<br/>

---

### 메모이제이션?

> - 컴퓨터 과학에서 자주 사용하는 기법, 이전 계산 결과를 캐시에 저장
>
> 동일한 입력이 다시 주어지면 캐시된 결과를 반환하여 불필요한 계산을 피하는 방법
>
> 함수나 값의 참조를 유지하는 데 활용

<br/>

---

### useCallback 사용한 함수 메모이제이션

- useCallback 훅을 사용하면 특정 의존성 변경되지 않는 한 함수 참조가 유지
  - 리렌더링 때에도 의존성 변경되지 않는 한 동일한 함수가 계속해서 사용

```jsx
const MyComponent = () => {
  const fetchInitialData = useCallback(() => {
    // 데이터를 가져오는 함수
    console.log("Fetching data...");
  }, []); // 빈 배열을 의존성으로 전달하여 함수 참조 유지

  useEffect(() => {
    fetchInitialData();
  }, [fetchInitialData]); // 이제 useEffect는 fetchInitialData가 변경될 때만 실행됨

  return <div>My Component</div>;
};
```

- useCallback을 사용해서 의존성 배열에 전달된 값이 변경되지 않는 한 메모이제이션 되게 한 케이스
  - 이 경우 의존성 빈 배열, 컴포넌트 첫 렌더링 때만 한 번 생성됐다가 이후에는 새로운 함수 안 생김
  - fetchInitialData를 의존성으로 추가해도 함수는 변경되지 않아서 useEffect는 처음 한 번만 실행

<br/>

---

### 왜 메모이제이션이 중요할까?

- 컴포넌트가 상태 변화나 부모 컴포넌트 리렌더링으로 인해 여러 번 렌더링 될 수 있어서
  - 매번 렌더링마다 내부에서 정의된 함수가 새롭게 정의되면?
  - 불필요한 연산이 늘거나 useEffect 등 훅이 불필요하게 재실행될 수 있음
- 메모이제이션을 통해 함수 참조를 유지하면 해당 문제를 피할 수 있다.

<br>

---

### 해당 함수의 참조를 유지한다?

> - JavaScript에서 함수는 일급 객체(first-class object)

- 이는 함수가 변수에 할당될 수 있고
- 다른 함수의 인자로 전달될 수 있으며
- 반환 값으로도 사용될 수 있는 것

```jsx
const result = greeting('name');

const searchUser = (getUser(user)) => {

};

const getImg = () => {
	return accessImg();
}
```

```jsx
const myFunction = () => {
  console.log("Hello, world!");
};
```

- 위에서 식별자는 함수에 대한 참조를 가진다
  - 이 참조는 해당 함수가 메모리에 있는 위치를 가르킨다

<br>

---

### 리액트에서의 함수 참조와 렌더링

- 리액트 컴포넌트는 상태 변경되거나 부모 컴포넌트 렌더링 될 때마다 리렌더링
  - 컴포넌트 내부 정의된 모든 변수와 함수도 다시 정의되어버림

```jsx
const MyComponent = () => {
  const handleClick = () => {
    console.log("Button clicked!");
  };

  return <button onClick={handleClick}>Click me</button>;
};
```

- 이벤트 핸들러가 리렌더링마다 새롭게 정의되는 걸 뜻함

<br>

---

### useCallback과 함수 참조 유지

- 리액트에서 useCallback 훅을 사용해서 특정 의존성 변경되지 않는 한 함수의 참조를 동일하게 유지 가능
  - 리렌더링 발생해도 동일한 함수 참조를 사용

```jsx
const MyComponent = () => {
  const handleClick = useCallback(() => {
    console.log("Button clicked!");
  }, []); // 빈 배열이므로, 함수 참조는 처음 한 번만 생성됨

  return <button onClick={handleClick}>Click me</button>;
};
```

- 이벤트 핸들러가 처음 렌더링 때만 정의되었다가 이후에는 새로운 참조가 생기지 않는다
  - 내부적으로 이전에 생성된 함수의 참조를 그대로 사용하니까

<br>

---

### 왜 참조를 유지하는 게 중요할까?

- 성능 최적화
  - 불필요한 함수 재생성이 없으니까
- 불필요한 훅 실행 방지
  - useEffect 훅은 의존성 배열에 함수도 포함할 수 있다
  - 이때 대상 함수가 useCallback 등을 통해 함수 참조가 유지된다면 해당 의존성이 변하지 않는 한 useEffect에서의 변경도 없음
  - 따라서 훅이 불필요하게 실행되는 걸 방지
- 안정성 향상
  - 참조가 변경되지 않으면 함수가 참조하는 상태나 값들이 예상치 못하게 변경되는 일을 막을 수 있다

<br>

---

### 렌더링 관점

- 렌더링이 일어나는 이유
  - state, props 등 동등 비교에 따른 결과이기 때문
- props의 동등 비교?
  - 객체의 얕은 비교를 기반으로 이루어짐

<br>

---

### 얕은 비교란?

- 객체 최상위 속성들만 비교하는 방식
  - 아래처럼 JS는 객체의 참조만을 비교하며 이를 얕은 비교라고 함

```jsx
const obj1 = { name: "Alice", age: 25 };
const obj2 = { name: "Alice", age: 25 };
const obj3 = obj1;

console.log(obj1 === obj2); // false
// 왜? 단순히 내용이 같은 게 아니라, 새롭게 쓰여졌기 때문
console.log(obj1 === obj3); // true
// 왜? 단순히 내용이 같은 것 뿐만 아니라 obj1과 같은 객체를 참조하기 때문에
```

<br>

---

### 리액트에서의 얕은 비교

> 성능 최적화를 위한 중요 메커니즘
>
> 컴포넌트 props나 state가 변경되었는지 확인하기 위해 얕은 비교 사용

- props의 얕은 비교
  - 부모 컴포넌트 → 자식 컴포넌트에 props 전달할 때 리액트는 새로운 props 객체와 이전 props 객체를 얕게 비교
  - 어떤 속성도 변경되지 않았다면 자식 컴포넌트를 다시 렌더링할 필요 없다 판단
- state의 얕은 비교
  - 컴포넌트 내에서 state 변경할 때 리액트는 새로운 상태 객체와 이전 상태 객체를 얕게 비교
  - 상태 객체가 동일하다면 컴포넌트 리렌더링 안함

<br>

---

### 얕은 비교 예제

```jsx
const MyComponent = React.memo(({ data }) => {
  console.log("MyComponent rendered");
  return <div>{data.name}</div>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = { name: "Alice" };

  return (
    <>
      <MyComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
};
```

- React.memo로 감싸진 컴포넌트
  - 컴포넌트 props가 변경되지 않으면 다시 렌더링되지 않도록 하는 의도
  - 그런데 data가 항상 새로운 객체로 생성된다면?
  - 얕은 비교에 의해 MyComponent는 매번 리렌더링
  - 문제 해결을 위해서는 data 객체를 메모이제이션 해야 함

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = useMemo(() => ({ name: "Alice" }), []); // 데이터 객체를 메모이제이션

  return (
    <>
      <MyComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
};
```

- 위와 같이 정의하면 data 객체는 처음 렌더링 때만 생성
- 이후 count 변경되어도 data 객체는 동일한 참조 유지
  - MyComponent는 리렌더링 되지 않는다

> 객체의 참조만을 비교하므로 동일한 참조를 유지하는 객체는 변경되지 않았다고 판단할 수 있게 된다
>
> 이를 이해하고 활용하면 불필요한 렌더링 줄이고 컴포넌트 성능 최적화 가능

<br>

---

### 원시 타입

> - 객체가 아닌 다른 모든 타입, 이런 타입은 메서드를 갖지 않음

- `undefined`
  - 선언 후 값 할당하지 않은 변수 또는 값 주어지지 않은 인수에 자동으로 할당되는 값

```jsx
let foo; // 미할당
typeof foo === "undefined"; // true, 할당된 게 없으니까

function bar(hello) {
  return hello;
}
typeof bar() === "undefined"; // true, 인수를 전달하지 않았으니까

console.log(typeof bar(42)); // 'number'
console.log(typeof bar("hello")); // 'string'
console.log(typeof bar(true)); // 'boolean'
console.log(typeof bar({})); // 'object'
console.log(typeof bar(null)); // 'object'
console.log(typeof bar(undefined)); // 'undefined'
console.log(typeof bar(function () {})); // 'function'
console.log(typeof bar([1, 2, 3])); // 'object'
```

- `null`
  - 아직 값이 없거나 비어 있는 값 표현할 때
  - 초창기 js가 값 표현하는 방식 때문에 발생한 문제
  - 명시적으로 비어있는 값

```jsx
typeof null === "object"; // true? ...
```

- `Boolean`
  - 조건문 내에서 false로 취급되는 값 `falsy`, falsy로 취급되는 값 이외는 `truthy` 값으로 취급된다.
  - `false`, `0`, `’’(빈 문자열)`, `null`, `undefined`, `NaN`는 모두 falsy 값이다.
  - `{}`,`[]` 는 내부에 값 존재하는지 여부와 상관없이 truthy 값으로 취급된다, 내부 값이 없더라도 배열과 객체는 존재하니까

```jsx
if (1) {
  // true
}

if (0) {
  // false
}

if (NaN) {
  // false
}

Boolean(1); // true
Boolean(0); // false
Boolean(true); // true
```

- Number

  - 2진수, 8진수, 16진수 등 별도 데이터 타입을 제공하지 않는다.
  - 따라서 각 진수별로 값을 표현해도 모두 10진수로 해석되어 동일한 값으로 표시된다.
  - 실제 사용 가능한 숫자의 범위는 `Number.MIN_SAFE_INTEGERD`와 `Number.MAX_SAFE_INTEGER`로 정의되어 있다.

- BigInt

  - Number 타입으로는 안전한게 표현할 수 없는 매우 큰 정수 값을 다룰 때 사용.
  - 정수 리터럴 뒤에 `n`을 붙여서 생성 || BigInt() 생성자로 호출

- String
  - 텍스트 타입 데이터.
  - 템플릿 리터럴(````) 사용 가능.
  - 템플릿 리터럴 특징 1: 표현식 사용 가능.
  - 템플릿 리터럴 특징 2: 이스케이스 시퀀스 없이 줄 띄우기, 들여쓰기, 빈 칸 등 가능
  - 템플릿 리터럴 특징 3: 함수 호출을 통해 템플릿 리터럴 조작 가능

```jsx
const multiLineString = `This is line one.
This is line two.`;

const stringWithSpaces = `  This line starts with two spaces.`;

/** 표현식이 ...values로 처리됨 */
function tag(strings, ...values) {
  console.log(strings);
  console.log(values);
}

const name = "John";
const age = 30;

tag`My name is ${name} and I am ${age} years old.`;
```

- Symbol
  - 중복되지 않는 고유한 값을 나타내기 위해 사용.
  - 심벌 함수 `Symbol()`을 사용해서만 만들 수 있다.

```jsx
let x = Symbol.for('hello');
undefined
let y = Symbol.for('hello');
undefined
console.log(x === y);
VM1448:1 true
undefined
let v = Symbol('hello');
undefined
let w = Symbol('hello');
undefined
console.log(v === w);
VM1608:1 false
```

<br>

---

### 객체 타입

객체 타입은 원시 타입 이외의 모든것, `배열` `함수` `정규식` `클래스` 등이 포함된다.

참조를 전달한다고 해서 `참조 타입(reference type)`으로도 불린다.

> 원시 타입은 불변 형태의 값으로 저장되지만 객체 타입은 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

```jsx
typeof [] === "object"; // true
typeof {} === "object"; // true

function hello() {}

typeof hello === "function"; // true

const hello1 = function () {};
const hello2 = function () {};

hello1 === hello2; // false, 구성이 똑같아도 어떤 참조를 갖는지 달라서
```

```jsx
let hello = "123";
let hi = hello;

console.log(hello === hi); // true

let obj1 = { name: "mimi" };
let obj2 = { name: "mimi" };

// 객체의 참조가 다르기 때문에 객체 자체는 다르다고 비교됨
console.log(obj1 === obj2); // false
// 하지만 값이 어떠한지 비교할 순 있다
console.log(obj1.name === obj2.name); // true
```

<br/>

---

### Object.is

- `Object.is` 메서드는 두 값을 비교할 때 사용된다.
- 엄격한 동등 비교(`===`)와 유사한 기능을 하지만 몇 가지 차이가 있다.
  - 타입을 정확히 지정한다
  - +- 기호를 따진다
  - NaN이 되는 경우를 따져준다
- 하지만 객체 비교에는 별 차이가 없다.

```jsx
Object.is(NaN, NaN); // true
NaN === NaN; // false

Object.is(+0, -0); // false
+0 === -0; // true

Object.is(NaN, 0 / 0); // true
NaN === 0 / 0; // false

Object.is({}, {}); // false;

let a = {
  hello: "hi",
};
let b = a;

console.log(Object.is(a, b)); // true
console.log(a === b); // true

let c = { ...a };
console.log(Object.is(a, c)); // false
console.log(a === c); // false
// 스프레드를 통해 새로운 참조를 줬으니까
```

<br/>

---

### 리액트에서의 동등 비교

- 리액트에서는 상태나 속성의 변경을 감지하고 리렌더링을 결정할 때 주로 얕은 비교를 수행한다.

- React에서는 이러한 비교를 위해 `Object.is`를 기반으로 하는 `shallowEqual`이라는 함수를 통해 얕은 비교를 수행한다.

> **얕은 비교를 수행하는 이유**

1. 깊은 비교에 비해 계산 비용이 훨씬 낮다.
2. 대부분은 최상위 수준의 프로퍼티에 상태 변경이 발생한다.
3. React는 불변성을 권장하기에 얕은 비교를 통해 객체가 변경되었는지 쉽게 판단한다.
4. 개발자가 선택적으로 깊은 비교를 수행할 수 있게 한다.

<br/>

---

### 일급 객체

- 자바스크립트에서 함수는 일급 객체다.
- 함수는 다른 함수의 매개 변수 또는 값으로 사용될 수 있다.

<br/>

---

### 함수 표현식과 선언 식의 차이

- 가장 큰 차이는 호이스팅 여부다.
  - 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다.
  - 이를 통해 코드의 순서와 상관 없이 정상적으로 함수를 호출할 수 있게 한다.

```jsx
console.log(hello()); // 안녕

function hello() {
  return "안녕";
}
```

- 반면 함수 표현식은 함수를 변수에 할당한다.
  - 함수가 값으로써 변수에 할당될 때에는 함수 호이스팅과는 다르게 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다.

```jsx
console.log(hello()); // hello is not a function

var hello = () => "안녕";
```

<br/>

---

### 화살표 함수

화살표 함수는 일반 함수 생성 방식과 차이가 있다.

1. 생성자 함수로 화살표 함수를 사용할 수 없다.

```jsx
const Car = (name) => {
  this.name = name;
};

const car1 = new Car("자동차"); // Car is not a constructor
```

2. arguments가 존재하지 않는다.

```jsx
function hi() {
  console.log(arguments);
}

// Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
hi(1, 2, 3);

const hello = () => console.log(arguments);

hello(1, 2, 3); // arguments is not defined

/* rest parameter */
const hello = (...rest) => console.log(rest);

hello(1, 2, 3); // [1,2,3]
```

3. this 바인딩이 다르다.

- 화살표 함수는 this가 선언되는 시점에 이미 상위 스코프로 결정 <-> 일반 함수는 호출 런타임 시점에 결정되는 this를 그대로 따름.

```jsx
class MyClass {
  constructor() {
    this.name = "MyClass";
  }

  // 일반 함수
  logName() {
    console.log(this.name);
  }

  // 호출 컨텍스트 변경 예시
  callWithDifferentContext() {
    const log = this.logName; // logName 함수를 변수에 할당
    log(); // 여기서 log는 그냥 일반 함수처럼 호출됨
  }
}

const myClassInstance = new MyClass();
myClassInstance.logName(); // 출력: "MyClass"
myClassInstance.callWithDifferentContext(); // 출력: undefined 또는 전역 객체의 속성
```

```jsx
class MyClass {
  constructor() {
    this.name = "MyClass";
  }

  // 화살표 함수
  logNameArrow = () => {
    console.log(this.name);
  };

  callWithDifferentContext() {
    const log = this.logNameArrow; // logNameArrow 함수를 변수에 할당
    log(); // 화살표 함수에서 this는 상위 스코프의 this를 그대로 가리킴
  }
}

const myClassInstance = new MyClass();
myClassInstance.logNameArrow(); // 출력: "MyClass"
myClassInstance.callWithDifferentContext(); // 출력: "MyClass"
```

```jsx
/** 클래스 형 컴포넌트 및 일반 함수를 바인딩해서 사용 케이스 */
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };

    // this를 바인딩
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

```jsx
/** 일반 함수 쓸 때 바인딩하지 않으면 전역 객체를 참조하게 되므로 올바른 실행이 힘들다 */
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

```jsx
/** 클래스 형 컴포넌트 및 화살표 함수 사용 케이스 */
class MyComponent extends React.Component {
  state = { count: 0 };

  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

<br>

---

### 즉시 실행 함수

- 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 정의되자마자 즉시 실행되는 자바스크립트 함수
- 이 함수는 주로 전역 범위에서의 변수 오염을 방지하기 위해 사용

```jsx
(function () {
  // 함수 내부의 코드
})();
```

||

```jsx
(() => {
  // 함수 내부의 코드
})();
```

> - 즉시 실행 함수는 함수 표현식으로 작성되며, 이 함수가 정의되자마자 ()에 의해 바로 실행
> - 함수 내부에서 정의된 변수와 함수는 IIFE 내부에서만 유효하며, 외부에서는 접근할 수 없다 -이를 통해 코드의 캡슐화를 이룰 수 있다

```jsx
/** 즉시 실행 함수로 UserList 객체 생성 및 배열에 접근 가능한 함수들 반환 */
const UserList = (() => {
  const users = []; // IIFE 내부에서만 접근 가능한 변수, 외부에서 접근할 수 없다, 리턴으로 언급하지 않을 거니까

  /** 객체는 외부에 접근 가능하고 함수도 열어 놓을 수 있으니까 UserList.getUser와 같은 동작은 가능 */
  return {
    getUser: () => users,

    addUser: (user) => {
      users.push(user);
      return users;
    },

    removeUser: () => {
      users.pop();
      return users;
    },
  };
})();
```

```jsx
/** 한 번 선언 후 재호출 안하는 케이스 */
(function (a, b) {
  return a + b;
})(10, 24);

((a, b) => {
  return a + b;
})(10, 24);
```
