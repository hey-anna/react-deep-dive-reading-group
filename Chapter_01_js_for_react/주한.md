# 주한

### 리액트 개발을 위해 꼭 알아야 할 JavaScript

- 리액트 코드 기반이 되는 JavaScript
- 웹 애플리케이션이 작동하도록 리액트가 수행하는 작업을 이해하기 위해서는 JavaScript를 짚어볼 필요가 있다.

<br/>

---

### JavaScript의 동등 비교: 의존성 배열?

- 리액트에서 함수형 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열을 자주 보게 된다.

<br/>

---

### 의존성 배열

- `useEffect`, `useCallback`, `useMemo`와 같은 훅을 사용할 때 두 번째 인수로 전달되는 배열.
- 이 배열에는 특정 값들이 포함되며 해당 값들 변경될 때마다 해당 훅이 다시 실행되도록 설정하는 역할을 한다.

```jsx
useEffect(() => {
  console.log("의존성 요소 1 혹은 2가 바뀌었습니다.");
}, [의존성1, 의존성2]);
```

- 훅 실행 시점을 효율적으로 제어할 수 있도록 돕는다, 이를 올바르게 설정하지 않으면 불필요하게 훅이 반복 실행되거나 반대로 필요한 시점에 훅이 실행되지 않을 수도 있다.
  - 빈 배열: 훅이 한 번만 실행, 초기화 작업 혹은 한 번만 실행될 때 사용
  - 특정 값들 포함한 배열: 배열에 포함된 값들이 변경될 때만 훅이 다시 실행
  - 의존성 배열을 생략?: 매번 렌더링 될 때마다 훅이 실행, 권장되지 않는 방법이며 무한 루프나 성능 문제 생길 수 있음

<br/>

---

### 설정에 따라서

- eslint-react-config에 선언돼 있는 react-hooks/exhaustive-deps의 도움을 받아 해당 배열을 채울 수도 있다

<br/>

---

### ESLint와 eslint-plugin-react-hooks

- ESLint는 코드 스타일 문제 자동 감지, 개발자에게 개선 권장하는 도구.
- 리액트 프로젝트에서는 eslint-plugin-react-hooks 플러그인이 자주 사용되며 리액트 훅을 올바르게 사용했는지 확인해주는 규칙들을 제공한다.
- react-hooks/exhaustive-deps 규칙은 해당 플러그인에 포함된 규칙 중 하나고 hooks에서 의존성 배열을 정확하게 관리하도록 돕는다.
  - 의존성 누락 감지: 의존성 배열에 누락된 변수가 있다면 이를 감지하고 경고를 발생시킴
  - 자동 수정 제안: ESLint는 의존성 자동 감지 뿐 아니라 자동 추가 기능도 제공한다.
  - 어떤 값 포함해야 하는지 헷갈릴 수 있는데 이때 의존성을 추천 받을 수 있다.

```jsx
useEffect(() => {
  fetchData(someProp); // someProp 사용
}, []); // 이 배열이 빈 경우, someProp이 변경되더라도 useEffect는 실행되지 않는 게 맞다. 그러면 본문에서 파라미터는 왜 넣는 거지?
```

- someProp이 의존성 배열에 포함되지 않았다 → someProp이 변경되어도 useEffect는 실행되지 않는 문제가 발생할 수 있다
  - 해당 규칙이 이를 감지해서 경고를 띄우고 제안하는 걸 뜻함

<br/>

---

### 실제 react-hooks/exhaustive-deps 사용 케이스

- 한 번만 실행됐으면 좋겠다
  - 의존성 배열을 빈 배열로 설정
  - 컴포넌트 마운트 때만 실행, 이후에는 의존성 배열 변화가 없다, 재실행 X

```jsx
useEffect(() => {
  // 초기화 코드, 예를 들어 API 호출
  fetchInitialData();
}, []); // 빈 배열을 통해 최초 마운트 시에만 실행
```

- 규칙과 상호작용
  - 규칙은 useEffect 등 의존성 배열 가진 훅 내부에서 사용할 모든 변수를 의존성 배열에 포함시키도록 권장
  - 만약 위 코드에서 초기 데이터 호출 함수가 외부에서 정의되었고 의존성 배열에 포함되지 않았다면 경고 발생 가능

```jsx
const fetchInitialData = () => {
  // 데이터를 가져오는 함수
};

useEffect(() => {
  fetchInitialData(); // ESLint가 경고를 줄 수 있음
}, []);
```

- 규칙에 의해 함수를 의존성 배열에 추가하라 제안할 수 있다

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]); // 제안된 수정 사항
```

- 규칙을 무시해도 될 때 → ESLint 경고를 무시하면 됨
  - 굳이 규칙을 준수하지 않아도 된다면
  - 함수가 변경되더라도 useEffect가 다시 실행될 필요 없는 경우
  - 혹은 초기화 시 한 번만 실행되길 원한다면

```jsx
useEffect(() => {
  fetchInitialData(); // 초기화 작업
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---

### 함수도 의존성 배열에 포함될 수 있는 배경

- 리액트에서 컴포넌트는 함수형 컴포넌트로 작성되는 경우 많다
- 컴포넌트 안에서 함수들이 정의
- useEffect에서 함수들을 호출할 수 있음
  - 그런데 함수 자체도 의존성 배열에 포함될 수 있다

<br/>

---

### 리액트 훅과 함수 관계

- 리액트 컴포넌트는 상태(state)나 props 변경마다 리렌더링

> - 이 과정에서 컴포넌트 내 모든 함수도 재정의되기 때문
> - 리액트는 함수 참조가 변경될 수 있다 판단해서 의존성 배열에 포함시키도록 권장하기도 한다.

```jsx
const MyComponent = () => {
  const fetchInitialData = () => {
    // 데이터 가져오는 함수
  };

  useEffect(() => {
    fetchInitialData();
  }, []);
};
```

- 위 코드에서 사실 fetchInitialData 함수는 컴포넌트 리렌더링마다 새로 정의되는 것과 같음
- 따라서 규칙이 의존성 배열에 함수를 포함하라 경고를 줄 수 있음
  - 리액트 생각 1 : 컴포넌트가 리렌더링될텐데, 그럼 함수도 새로 쓰이는 거랑 다름 없어서 변경될 수 있잖아?
  - 리액트 생각 2: 그럼 의존성 배열에 포함시켜야 useEffect 같은 의존성 기반 훅이 잘 작동하겠네?

<br/>

---

### 함수가 의존성 배열에 포함될 때

- 함수를 의존성 배열에 포함시키는 것은 리액트가 해당 함수 참조 변경마다 useEffect를 재실행하게 만드는 방법

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]);
```

- 위와 같은 코드에서는 함수 변경(== 리렌더링)마다 useEffect가 다시 실행

> - 리액트에서는 함수도 값과 마찬가지로 변경될 수 있는 상태로 간주, 이 경우를 대비해 의존성 배열에 포함시킨다.

<br/>

---

### 의도적으로 빈 배열을 사용해야 하는 경우

- 함수를 매번 재정의하더라도 useEffect를 한 번만 실행하고 싶다면 빈 배열 유지 혹은 useCallback을 사용해서 fetchInitialData를 메모이제이션(값을 캐시)할 수 있음.

```jsx
const fetchInitialData = useCallback(() => {
  // 데이터 가져오는 함수
}, []); // 의존성 배열이 빈 배열이므로, 함수가 재정의되지 않음

useEffect(() => {
  fetchInitialData();
}, []);
```

```jsx
useEffect(() => {
  fetchInitialData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---

### 함수의 메모이제이션?

- 위 맥락에서는 함수를 메모이제이션 한다는 상황으로 쓰임
- 함수가 재정의되지 않도록 해당 함수의 참조를 유지하는 걸 의미
  - 리렌더링마다 함수가 불필요하게 다시 생성되는 걸 방지

<br/>

---

### 메모이제이션?

> - 컴퓨터 과학에서 자주 사용하는 기법, 이전 계산 결과를 캐시에 저장
>
> 동일한 입력이 다시 주어지면 캐시된 결과를 반환하여 불필요한 계산을 피하는 방법
>
> 함수나 값의 참조를 유지하는 데 활용

<br/>

---

### useCallback 사용한 함수 메모이제이션

- useCallback 훅을 사용하면 특정 의존성 변경되지 않는 한 함수 참조가 유지
  - 리렌더링 때에도 의존성 변경되지 않는 한 동일한 함수가 계속해서 사용

```jsx
const MyComponent = () => {
  const fetchInitialData = useCallback(() => {
    // 데이터를 가져오는 함수
    console.log("Fetching data...");
  }, []); // 빈 배열을 의존성으로 전달하여 함수 참조 유지

  useEffect(() => {
    fetchInitialData();
  }, [fetchInitialData]); // 이제 useEffect는 fetchInitialData가 변경될 때만 실행됨

  return <div>My Component</div>;
};
```

- useCallback을 사용해서 의존성 배열에 전달된 값이 변경되지 않는 한 메모이제이션 되게 한 케이스
  - 이 경우 의존성 빈 배열, 컴포넌트 첫 렌더링 때만 한 번 생성됐다가 이후에는 새로운 함수 안 생김
  - fetchInitialData를 의존성으로 추가해도 함수는 변경되지 않아서 useEffect는 처음 한 번만 실행

<br/>

---

### 왜 메모이제이션이 중요할까?

- 컴포넌트가 상태 변화나 부모 컴포넌트 리렌더링으로 인해 여러 번 렌더링 될 수 있어서
  - 매번 렌더링마다 내부에서 정의된 함수가 새롭게 정의되면?
  - 불필요한 연산이 늘거나 useEffect 등 훅이 불필요하게 재실행될 수 있음
- 메모이제이션을 통해 함수 참조를 유지하면 해당 문제를 피할 수 있다.

<br>

---

### 해당 함수의 참조를 유지한다?

> - JavaScript에서 함수는 일급 객체(first-class object)

- 이는 함수가 변수에 할당될 수 있고
- 다른 함수의 인자로 전달될 수 있으며
- 반환 값으로도 사용될 수 있는 것

```jsx
const result = greeting('name');

const searchUser = (getUser(user)) => {

};

const getImg = () => {
	return accessImg();
}
```

```jsx
const myFunction = () => {
  console.log("Hello, world!");
};
```

- 위에서 식별자는 함수에 대한 참조를 가진다
  - 이 참조는 해당 함수가 메모리에 있는 위치를 가르킨다

<br>

---

### 리액트에서의 함수 참조와 렌더링

- 리액트 컴포넌트는 상태 변경되거나 부모 컴포넌트 렌더링 될 때마다 리렌더링
  - 컴포넌트 내부 정의된 모든 변수와 함수도 다시 정의되어버림

```jsx
const MyComponent = () => {
  const handleClick = () => {
    console.log("Button clicked!");
  };

  return <button onClick={handleClick}>Click me</button>;
};
```

- 이벤트 핸들러가 리렌더링마다 새롭게 정의되는 걸 뜻함

<br>

---

### useCallback과 함수 참조 유지

- 리액트에서 useCallback 훅을 사용해서 특정 의존성 변경되지 않는 한 함수의 참조를 동일하게 유지 가능
  - 리렌더링 발생해도 동일한 함수 참조를 사용

```jsx
const MyComponent = () => {
  const handleClick = useCallback(() => {
    console.log("Button clicked!");
  }, []); // 빈 배열이므로, 함수 참조는 처음 한 번만 생성됨

  return <button onClick={handleClick}>Click me</button>;
};
```

- 이벤트 핸들러가 처음 렌더링 때만 정의되었다가 이후에는 새로운 참조가 생기지 않는다
  - 내부적으로 이전에 생성된 함수의 참조를 그대로 사용하니까

<br>

---

### 왜 참조를 유지하는 게 중요할까?

- 성능 최적화
  - 불필요한 함수 재생성이 없으니까
- 불필요한 훅 실행 방지
  - useEffect 훅은 의존성 배열에 함수도 포함할 수 있다
  - 이때 대상 함수가 useCallback 등을 통해 함수 참조가 유지된다면 해당 의존성이 변하지 않는 한 useEffect에서의 변경도 없음
  - 따라서 훅이 불필요하게 실행되는 걸 방지
- 안정성 향상
  - 참조가 변경되지 않으면 함수가 참조하는 상태나 값들이 예상치 못하게 변경되는 일을 막을 수 있다

<br>

---

### 렌더링 관점

- 렌더링이 일어나는 이유
  - state, props 등 동등 비교에 따른 결과이기 때문
- props의 동등 비교?
  - 객체의 얕은 비교를 기반으로 이루어짐

<br>

---

### 얕은 비교란?

- 객체 최상위 속성들만 비교하는 방식
  - 아래처럼 JS는 객체의 참조만을 비교하며 이를 얕은 비교라고 함

```jsx
const obj1 = { name: "Alice", age: 25 };
const obj2 = { name: "Alice", age: 25 };
const obj3 = obj1;

console.log(obj1 === obj2); // false
// 왜? 단순히 내용이 같은 게 아니라, 새롭게 쓰여졌기 때문
console.log(obj1 === obj3); // true
// 왜? 단순히 내용이 같은 것 뿐만 아니라 obj1과 같은 객체를 참조하기 때문에
```

<br>

---

### 리액트에서의 얕은 비교

> 성능 최적화를 위한 중요 메커니즘
>
> 컴포넌트 props나 state가 변경되었는지 확인하기 위해 얕은 비교 사용

- props의 얕은 비교
  - 부모 컴포넌트 → 자식 컴포넌트에 props 전달할 때 리액트는 새로운 props 객체와 이전 props 객체를 얕게 비교
  - 어떤 속성도 변경되지 않았다면 자식 컴포넌트를 다시 렌더링할 필요 없다 판단
- state의 얕은 비교
  - 컴포넌트 내에서 state 변경할 때 리액트는 새로운 상태 객체와 이전 상태 객체를 얕게 비교
  - 상태 객체가 동일하다면 컴포넌트 리렌더링 안함

<br>

---

### 얕은 비교 예제

```jsx
const MyComponent = React.memo(({ data }) => {
  console.log("MyComponent rendered");
  return <div>{data.name}</div>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = { name: "Alice" };

  return (
    <>
      <MyComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
};
```

- React.memo로 감싸진 컴포넌트
  - 컴포넌트 props가 변경되지 않으면 다시 렌더링되지 않도록 하는 의도
  - 그런데 data가 항상 새로운 객체로 생성된다면?
  - 얕은 비교에 의해 MyComponent는 매번 리렌더링
  - 문제 해결을 위해서는 data 객체를 메모이제이션 해야 함

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = useMemo(() => ({ name: "Alice" }), []); // 데이터 객체를 메모이제이션

  return (
    <>
      <MyComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
};
```

- 위와 같이 정의하면 data 객체는 처음 렌더링 때만 생성
- 이후 count 변경되어도 data 객체는 동일한 참조 유지
  - MyComponent는 리렌더링 되지 않는다

> 객체의 참조만을 비교하므로 동일한 참조를 유지하는 객체는 변경되지 않았다고 판단할 수 있게 된다
>
> 이를 이해하고 활용하면 불필요한 렌더링 줄이고 컴포넌트 성능 최적화 가능

<br>

---

### 원시 타입

> - 객체가 아닌 다른 모든 타입, 이런 타입은 메서드를 갖지 않음

- `undefined`
  - 선언 후 값 할당하지 않은 변수 또는 값 주어지지 않은 인수에 자동으로 할당되는 값

```jsx
let foo; // 미할당
typeof foo === "undefined"; // true, 할당된 게 없으니까

function bar(hello) {
  return hello;
}
typeof bar() === "undefined"; // true, 인수를 전달하지 않았으니까

console.log(typeof bar(42)); // 'number'
console.log(typeof bar("hello")); // 'string'
console.log(typeof bar(true)); // 'boolean'
console.log(typeof bar({})); // 'object'
console.log(typeof bar(null)); // 'object'
console.log(typeof bar(undefined)); // 'undefined'
console.log(typeof bar(function () {})); // 'function'
console.log(typeof bar([1, 2, 3])); // 'object'
```

- `null`
  - 아직 값이 없거나 비어 있는 값 표현할 때
  - 초창기 js가 값 표현하는 방식 때문에 발생한 문제
  - 명시적으로 비어있는 값

```jsx
typeof null === "object"; // true? ...
```

- `Boolean`
  - 조건문 내에서 false로 취급되는 값 `falsy`, falsy로 취급되는 값 이외는 `truthy` 값으로 취급된다.
  - `false`, `0`, `’’(빈 문자열)`, `null`, `undefined`, `NaN`는 모두 falsy 값이다.
  - `{}`,`[]` 는 내부에 값 존재하는지 여부와 상관없이 truthy 값으로 취급된다, 내부 값이 없더라도 배열과 객체는 존재하니까

```jsx
if (1) {
  // true
}

if (0) {
  // false
}

if (NaN) {
  // false
}

Boolean(1); // true
Boolean(0); // false
Boolean(true); // true
```

- Number

  - 2진수, 8진수, 16진수 등 별도 데이터 타입을 제공하지 않는다.
  - 따라서 각 진수별로 값을 표현해도 모두 10진수로 해석되어 동일한 값으로 표시된다.
  - 실제 사용 가능한 숫자의 범위는 `Number.MIN_SAFE_INTEGERD`와 `Number.MAX_SAFE_INTEGER`로 정의되어 있다.

- BigInt

  - Number 타입으로는 안전한게 표현할 수 없는 매우 큰 정수 값을 다룰 때 사용.
  - 정수 리터럴 뒤에 `n`을 붙여서 생성 || BigInt() 생성자로 호출

- String
  - 텍스트 타입 데이터.
  - 템플릿 리터럴(````) 사용 가능.
  - 템플릿 리터럴 특징 1: 표현식 사용 가능.
  - 템플릿 리터럴 특징 2: 이스케이스 시퀀스 없이 줄 띄우기, 들여쓰기, 빈 칸 등 가능
  - 템플릿 리터럴 특징 3: 함수 호출을 통해 템플릿 리터럴 조작 가능

```jsx
const multiLineString = `This is line one.
This is line two.`;

const stringWithSpaces = `  This line starts with two spaces.`;

/** 표현식이 ...values로 처리됨 */
function tag(strings, ...values) {
  console.log(strings);
  console.log(values);
}

const name = "John";
const age = 30;

tag`My name is ${name} and I am ${age} years old.`;
```

- Symbol
  - 중복되지 않는 고유한 값을 나타내기 위해 사용.
  - 심벌 함수 `Symbol()`을 사용해서만 만들 수 있다.

```jsx
let x = Symbol.for('hello');
undefined
let y = Symbol.for('hello');
undefined
console.log(x === y);
VM1448:1 true
undefined
let v = Symbol('hello');
undefined
let w = Symbol('hello');
undefined
console.log(v === w);
VM1608:1 false
```

<br>

---

### 객체 타입

객체 타입은 원시 타입 이외의 모든것, `배열` `함수` `정규식` `클래스` 등이 포함된다.

참조를 전달한다고 해서 `참조 타입(reference type)`으로도 불린다.

> 원시 타입은 불변 형태의 값으로 저장되지만 객체 타입은 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

```jsx
typeof [] === "object"; // true
typeof {} === "object"; // true

function hello() {}

typeof hello === "function"; // true

const hello1 = function () {};
const hello2 = function () {};

hello1 === hello2; // false, 구성이 똑같아도 어떤 참조를 갖는지 달라서
```

```jsx
let hello = "123";
let hi = hello;

console.log(hello === hi); // true

let obj1 = { name: "mimi" };
let obj2 = { name: "mimi" };

// 객체의 참조가 다르기 때문에 객체 자체는 다르다고 비교됨
console.log(obj1 === obj2); // false
// 하지만 값이 어떠한지 비교할 순 있다
console.log(obj1.name === obj2.name); // true
```

<br/>

---

### Object.is

- `Object.is` 메서드는 두 값을 비교할 때 사용된다.
- 엄격한 동등 비교(`===`)와 유사한 기능을 하지만 몇 가지 차이가 있다.
  - 타입을 정확히 지정한다
  - +- 기호를 따진다
  - NaN이 되는 경우를 따져준다
- 하지만 객체 비교에는 별 차이가 없다.

```jsx
Object.is(NaN, NaN); // true
NaN === NaN; // false

Object.is(+0, -0); // false
+0 === -0; // true

Object.is(NaN, 0 / 0); // true
NaN === 0 / 0; // false

Object.is({}, {}); // false;

let a = {
  hello: "hi",
};
let b = a;

console.log(Object.is(a, b)); // true
console.log(a === b); // true

let c = { ...a };
console.log(Object.is(a, c)); // false
console.log(a === c); // false
// 스프레드를 통해 새로운 참조를 줬으니까
```

<br/>

---

### 리액트에서의 동등 비교

- 리액트에서는 상태나 속성의 변경을 감지하고 리렌더링을 결정할 때 주로 얕은 비교를 수행한다.

- React에서는 이러한 비교를 위해 `Object.is`를 기반으로 하는 `shallowEqual`이라는 함수를 통해 얕은 비교를 수행한다.

> **얕은 비교를 수행하는 이유**

1. 깊은 비교에 비해 계산 비용이 훨씬 낮다.
2. 대부분은 최상위 수준의 프로퍼티에 상태 변경이 발생한다.
3. React는 불변성을 권장하기에 얕은 비교를 통해 객체가 변경되었는지 쉽게 판단한다.
4. 개발자가 선택적으로 깊은 비교를 수행할 수 있게 한다.

<br/>

---

### 일급 객체

- 자바스크립트에서 함수는 일급 객체다.
- 함수는 다른 함수의 매개 변수 또는 값으로 사용될 수 있다.

<br/>

---

### 함수 표현식과 선언 식의 차이

- 가장 큰 차이는 호이스팅 여부다.
  - 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다.
  - 이를 통해 코드의 순서와 상관 없이 정상적으로 함수를 호출할 수 있게 한다.

```jsx
console.log(hello()); // 안녕

function hello() {
  return "안녕";
}
```

- 반면 함수 표현식은 함수를 변수에 할당한다.
  - 함수가 값으로써 변수에 할당될 때에는 함수 호이스팅과는 다르게 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다.

```jsx
console.log(hello()); // hello is not a function

var hello = () => "안녕";
```

<br/>

---

### 화살표 함수

화살표 함수는 일반 함수 생성 방식과 차이가 있다.

1. 생성자 함수로 화살표 함수를 사용할 수 없다.

```jsx
const Car = (name) => {
  this.name = name;
};

const car1 = new Car("자동차"); // Car is not a constructor
```

2. arguments가 존재하지 않는다.

```jsx
function hi() {
  console.log(arguments);
}

// Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
hi(1, 2, 3);

const hello = () => console.log(arguments);

hello(1, 2, 3); // arguments is not defined

/* rest parameter */
const hello = (...rest) => console.log(rest);

hello(1, 2, 3); // [1,2,3]
```

3. this 바인딩이 다르다.

- 화살표 함수는 this가 선언되는 시점에 이미 상위 스코프로 결정 <-> 일반 함수는 호출 런타임 시점에 결정되는 this를 그대로 따름.

```jsx
class MyClass {
  constructor() {
    this.name = "MyClass";
  }

  // 일반 함수
  logName() {
    console.log(this.name);
  }

  // 호출 컨텍스트 변경 예시
  callWithDifferentContext() {
    const log = this.logName; // logName 함수를 변수에 할당
    log(); // 여기서 log는 그냥 일반 함수처럼 호출됨
  }
}

const myClassInstance = new MyClass();
myClassInstance.logName(); // 출력: "MyClass"
myClassInstance.callWithDifferentContext(); // 출력: undefined 또는 전역 객체의 속성
```

```jsx
class MyClass {
  constructor() {
    this.name = "MyClass";
  }

  // 화살표 함수
  logNameArrow = () => {
    console.log(this.name);
  };

  callWithDifferentContext() {
    const log = this.logNameArrow; // logNameArrow 함수를 변수에 할당
    log(); // 화살표 함수에서 this는 상위 스코프의 this를 그대로 가리킴
  }
}

const myClassInstance = new MyClass();
myClassInstance.logNameArrow(); // 출력: "MyClass"
myClassInstance.callWithDifferentContext(); // 출력: "MyClass"
```

```jsx
/** 클래스 형 컴포넌트 및 일반 함수를 바인딩해서 사용 케이스 */
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };

    // this를 바인딩
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

```jsx
/** 일반 함수 쓸 때 바인딩하지 않으면 전역 객체를 참조하게 되므로 올바른 실행이 힘들다 */
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

```jsx
/** 클래스 형 컴포넌트 및 화살표 함수 사용 케이스 */
class MyComponent extends React.Component {
  state = { count: 0 };

  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

<br>

---

### 즉시 실행 함수

- 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 정의되자마자 즉시 실행되는 자바스크립트 함수
- 이 함수는 주로 전역 범위에서의 변수 오염을 방지하기 위해 사용

```jsx
(function () {
  // 함수 내부의 코드
})();
```

||

```jsx
(() => {
  // 함수 내부의 코드
})();
```

> - 즉시 실행 함수는 함수 표현식으로 작성되며, 이 함수가 정의되자마자 ()에 의해 바로 실행
> - 함수 내부에서 정의된 변수와 함수는 IIFE 내부에서만 유효하며, 외부에서는 접근할 수 없다 -이를 통해 코드의 캡슐화를 이룰 수 있다
> - 특정 기능을 모듈화하여 재사용성을 높일 수 있다
> - 사용자 관리 기능을 여러 컴포넌트에서 공유해야 할 때 이와 같은 패턴을 사용하여 안전하게 기능 사용

```jsx
/** 즉시 실행 함수로 userList 객체 생성 및 배열에 접근 가능한 함수들 반환 */
const userList = (() => {
  const users = []; // IIFE 내부에서만 접근 가능한 변수, 외부에서 접근할 수 없다, 리턴으로 언급하지 않을 거니까

  /** 객체는 외부에 접근 가능하고 함수도 열어 놓을 수 있으니까 UserList.getUser와 같은 동작은 가능 */
  return {
    getUser: () => users,

    addUser: (user) => {
      users.push(user);
      return users;
    },

    removeUser: () => {
      users.pop();
      return users;
    },
  };
})();
```

```jsx
/** 한 번 선언 후 재호출 안하는 케이스 */
(function (a, b) {
  return a + b;
})(10, 24);

((a, b) => {
  return a + b;
})(10, 24);
```

- 커스텀 훅
  - 패턴을 이용한 커스텀 훅 만들기, 사용자 목록 관리하는 useUsers 훅을 만든다 할 때

```jsx
import { useState } from 'react';

const useUsers = () => {
  const [users, setUsers] = useState<string[]>([]);

  const getUser = () => users;

  const addUser = (user: string) => {
    setUsers([...users, user]);
  };

  const removeUser = () => {
    setUsers(users.slice(0, -1));
  };

  return { getUser, addUser, removeUser };
};
```

- 유틸리티 함수 생성
  - 유틸리티 함수를 특정 모듈 내에서만 안전하게 사용하도록 만들 수 있음
  - 내부 로직 보호 & 필요에 따라 외부에 일부 기능만 공개

<br>

---

### 고차 함수

고차함수는 함수가 `일급 객체`라는 특성을 활용하여 함수를 인수로 받거나 반환하는 함수다.

- 함수를 인수로 받는 함수

```jsx
function executeFunction(fn: (x: number) => number, value: number): number {
  return fn(value);
}

// 사용 예제
const double = (x: number) => x * 2;
const result = executeFunction(double, 5); // 결과는 10
console.log(result);
```

- executeFunction 함수는 두 개의 인수를 받음:
  - fn: 숫자를 인수로 받아 숫자를 반환하는 함수
  - value: fn에 전달할 숫자 값

- executeFunction은 fn(value)를 실행하고 그 결과를 반환

---

- 함수를 반환하는 함수

```jsx
function createMultiplier(multiplier: number): (x: number) => number {
  return (x: number) => x * multiplier;
}

// 사용 예제
const triple = createMultiplier(3);
const result = triple(5); // 결과는 15
console.log(result);
```

- createMultiplier 함수는 multiplier라는 숫자를 인수로 받아, 또 다른 함수를 반환
  - 반환된 함수는 인수로 받은 숫자에 multiplier를 곱하기

---

- React 컴포넌트에서 고차 함수 사용하기 1: 함수를 인수로 받는 컴포넌트

```jsx
import React from 'react';

type ButtonProps = {
  onClick: () => void;
};

const Button: React.FC<ButtonProps> = ({ onClick }) => {
  return <button onClick={onClick}>Click me</button>;
};

// 사용 예제
const handleClick = () => {
  console.log('Button clicked!');
};

const App: React.FC = () => {
  return <Button onClick={handleClick} />;
};

export default App;
```

- Button 컴포넌트는 onClick 함수를 인수로 받아 클릭 시 함수 호출

---

- React 컴포넌트에서 고차 함수 사용하기 2: 함수를 인수로 받는 컴포넌트

```jsx
import React from 'react';

function withMessage(message: string): React.FC {
  return () => <h1>{message}</h1>;
}

// 사용 예제
const HelloWorld = withMessage('Hello, World!');

const App: React.FC = () => {
  return <HelloWorld />;
};

export default App;
```

- withMessage 함수는 message라는 문자열을 받아, 해당 메시지 표시하는 컴포넌트 반환
  - HelloWorld 컴포넌트는 withMessage를 통해 생성된 컴포넌트

<br>

---

### 클래스

- 자바스크립트에서 클래스는 객체를 생성하기 위한 템플릿이다.
  - 기존의 프로토타입 기반의 상속을 좀 더 쉽고 명확하게 사용할 수 있게 한다.
  - 클래스는 `데이터`와 데이터를 조작하는 `메서드`로 구성된다.

> **constructor**

- 생성자 함수, 객체 생성 시 사용되는 특수 메서드
- 객체마다 단 하나 생성할 수 있고 여러 개 사용한다면 에러 발생
- 생성자를 쓸 필요 없다면 생략 가능

```jsx
  class Car() {
    Car() {
      //...
    }
  }
```

<br>

> **프로퍼티**

- 클래스를 통해 실체가 있는 인스턴스 생성할 때 내부에 정의할 수 있는 속성 값을 의미
  - 대부분 이 필드 값들을 통해서 객체에게 간접 접근함

<br>

> **getter / settter**

- getter는 클래스 내부 값을 가져올 때 사용된다. `get` 키워드를 사용한다.
- setter는 클래스 내부 값을 할당할 때 사용된다. `set` 키워드를 사용한다.

<br>

> **인스턴스 메서드**

- 클래스 내부에서 선언한 메서드를 말한다.
- 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불리기도 한다.

<br>

> 정적 메서드

- 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드다.
- 정적 메서드 내부에서의 this는 클래스 자신을 가리킨다.
- `static` 키워드를 사용한다.

```jsx
  class Car() {
    static insertKey() {
      // 클래스가 가진 메서드
    }
  }
```

<br>

> 프로토타입 체인

- 프로토타입 체인은 객체가 자신의 프로퍼티나 메서드를 가지고 있지 않을 경우, 해당 객체의 프로토타입(부모 객체)로부터 프로퍼티나 메서드를 상속받는 메커니즘을 말한다.
  - 이러한 방식으로 자바스크립트에서는 객체 간의 `상속`을 구현한다.

```jsx
function Person(name) {
  this.name = name;
}

Person.prototype.getName = function () {
  console.log(`${this.name}`);
};

// person1은 getName 메서드를 직접 가지고 있지 않지만 Pserson.prototype에서 이를 상속 받았다.
// 이것이 프로토타입 체인의 기본적인 작동 방식이다.
const person1 = new Person('철수');

person1.getName(); // '철수'
```

<br>

---

### 클로저

- 자바스크립트에서 클로저는 함수와 그 함수가 선언된 `렉시컬 환경`과의 조합을 의미한다.
  - 클로저는 내부 함수가 외부 함수의 스코프에 있는 변수에 접근할 수 있게 해준다.
  - 외부 함수의 실행이 끝난 후에도 외부 함수의 변수에 접근할 수 있게 한다.
  - 이는 데이터 캡슐화와 정보 은닉을 구현할 때 유용하게 사용된다.

```jsx
function outerFunction() {
  const a = 12;

  function innerFunction() {
    // 내부 함수에서 외부 함수 스코프에 있는 변수에 접근 가능하다.
    console.log(a); // 12
  }

  return innerFunction;
}
```

<br>

> **클로저의 장점**

- `데이터의 캡슐화와 정보 은닉`
  - 특정 함수에 대한 접근 권한을 제한할 수 있으며, 전역 변수의 사용을 줄여 충돌을 방지할 수 있다.
- `상태 유지`
  - 외부 함수의 상태를 내부 함수가 호출될 때마다 유지할 수 있게 해준다.

<br/>

> **클로저의 단점**

- `메모리 사용`
  - 클로저는 선언될 따마다 그 선언적 환경을 기억해야하므로 이 변수들은 가비지 컬렉션의 대상이 되지 않아 메모리 사용이 증가할 수 있다.

<br/>

---

### 싱글 스레드

- 자바스크립트는 싱글 스레드 기반의 언어로, 한 번에 하나의 작업만 처리할 수 있다.
  - 이는 코드 실행이 순차적인 처리 방식을 의미한다.

- 이러한 특성은 간단하고 예측 가능한 프로그래밍 모델을 제공하지만 한 번에 많은 작업을 처리할 수 없다.
  - 이를 해결하기 위해 자바스크립트 환경에서는 `이벤트 루프`와 비동기 프로그래밍 모델을 사용한다.

<br>

> **왜 싱글스레드로 만들어졌을까?**

자바스크립트의 초기 목적은 사용자의 인터렉션, 간단한 애니메이션 처리 등이었으며 복잡한 멀티 스레딩을 필요로 하지 않았다.

<br>

---

### 이벤트 루프

이벤트 루프는 `호출 스택`, `이벤트 큐`, `백그라운드 태스크` 등 여러 구성 요소를 통해 싱글 스레드 환경에서 비동기 작업을 가능하게 하는 장치다.

<br>

> **호출 스택 (Call Stack)**

- 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.
- 함수가 호출되면 스택에 추가되고, 실행이 완료되면 제거된다.

<br>

> **태스크 큐 (이벤트 큐)**

- 태스크 큐는 완료된 백그라운드 태스크의 콜백 함수들이 실행을 기다리는 대기열이다. 여기서 태스크는 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미한다.
- 호출 스택이 비어 있을 때, 이벤트 루프는 태스크 큐에서 대기 중인 콜백 함수를 호출 스택으로 이동시켜 실행한다. 이 과정은 태스크 큐가 비워질 때까지 반복된다.

<br>

> **마이크로 태스크 큐**

- 이 큐는 프로미스와 같은 마이크로 태스크를 처리한다. 태스크 큐와는 별도로 관리되며, 이벤트 루프가 태스크 큐의 태스크를 처리하기 전에 **마이크로태스크 큐의 모든 작업을 우선적으로 처리**한다.
- 작업 순서는 마이크로 태스크큐 → 렌더링 → 태스크 큐 순서이다.

<br>

---

### 구조 분해 할당

구조 분해 할당은 배열이나 객체의 속성을 분해하여, 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식이다. 이 문법을 사용하면 데이터의 일부를 쉽게 추출하고, 코드의 가독성을 높일 수 있다.

```jsx
// 객체 구조 분해

const person = {
  name: '홍길동',
  age: 25,
};

const { name, age } = person;

console.log(name); // "홍길동"
console.log(age); // 25
```

<br>

`undefined` 일 경우에 기본 값이 사용된다는 점을 이용하여 아래와 같이 사용될 수도 있다.

```jsx
const required = argName => {
  throw new Error(`${argName} is required`);
};

function createCarousel({
  type = required('type'),
  image = 'default.jpg',
  time = 3000,
} = {}) {
  return { type, image, time };
}

createCarousel(); // Error: type is required
createCarousel3({ type: 'main' }); // { type: 'main', image: 'default.jpg', time: 3000 }
```

<br>

---

### 타입스크립트

- 타입스크립트는 자바스크립트의 모든 기능을 포함하며, 그 위에 정적 타입 검사와 같은 추가 기능을 제공한다.

- 자바스크립트는 동적 타입 언어로 변수의 타입이 런타임에 결정된다.
  - 반면에 타입스크립트는 런타임이 아닌 빌드 타임에 이러한 타입 체크를 수행할 수 있게 해주어 에러를 예방할 수 있다.

### 타입스크립트 활용법

> `any` 대신 `unknown` 사용

- `any`는 타입스크립트의 타입 검사 시스템을 무시한다.
  - 즉, 타입 체크를 하지 않는다.
  - 이는 런타임에 예상치 못한 에러를 발생시킬 위험이 높다.
- `unknown` 타입은 any와 마찬가지로 어떤 종류의 값이든 할당할 수 있다.
  - 하지만 `unknown` 타입 변수를 사용하기 전에 해당 변수의 타입을 확인하는 과정이 필요하다.
  - 즉, 타입 가드나 타입 단언을 사용하여 해당 변수의 실제 타입을 좁혀나가야 한다.
- 이러한 특성 때문에 `unknown` 타입은 타입 안전성을 유지하면서도 유연성을 제공한다.

  ```jsx
  function doSomething(callback: unknown) {
    if (typeof callback === 'function') {
      callback();
    }
  }
  ```

<br/>

> **never 타입**

- `never` 타입은 어떤 타입도 할당될 수 없음을 나타낸다.
  - 코드의 특정 부분이 절대 실행되지 않아야 함을 명시적으로 나타낼 수 있다.

  ```jsx
  function processEmptyObject(obj: Record<string, never>) {
    // 여기서 obj는 어떤 속성도 가지지 않는 객체여야 한다.
    console.log(obj);
  }

  processEmptyObject({}); // 성공: 비어 있는 객체
  processEmptyObject({ key: 'value' }); // 타입 에러: 'key' 속성이 있기 때문에 실패
  ```

<br/>

---

### 타입 가드

타입 가드는 특정 범위 내에서 변수의 타입을 보장하는 표현식이다.

타입 가드를 사용하는 일반적인 방법에는 `typeof`, `instanceof`, 사용자 정의 타입 가드가 있다.

<br/>

> **instanceof**

- `instanceof`는 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자다.

  ```jsx
  class Bird {
    fly() {
      console.log('bird flies');
    }
  }

  class Fish {
    swim() {
      console.log('fish swims');
    }
  }

  function move(pet: Bird | Fish) {
    // Bird 클래스인지 확인
    if (pet instanceof Bird) {
      pet.fly();
      // Fish 클래스인지 확인
    } else if (pet instanceof Fish) {
      pet.swim();
    }
  }

  const myBird = new Bird();
  const myFish = new Fish();

  move(myBird); // "bird flies"
  move(myFish); // "fish swims"
  ```

<br>

> **typeof**

- `typeof` 연산자는 변수의 데이터 타입을 문자열로 반환한다.

  ```jsx
  function foo(a: string | number) {
    if (typeof a === 'string') {
      console.log('string');
    }

    if (typeof a === 'number') {
      console.log('number');
    }
  }

  foo('dwd'); // string
  foo(1); // number
  ```

<br>

> **in**

- `in`은 property in object로 사용되는데, 주로 어떤 객체에 키가 존재하는지 용도로 사용된다.

  ```jsx
  interface Bird {
    fly(): void;
  }

  interface Fish {
    swim(): void;
  }

  function move(animal: Bird | Fish) {
    // fly 속성이 animal에 있는가?
    if ('fly' in animal) {
      animal.fly();
      // swim 속성이 animal에 있는가?
    } else if ('swim' in animal) {
      animal.swim();
    }
  }
  ```

<br>

> **사용자 정의 타입 가드**

- 사용자 정의 타입 가드는 함수를 사용하여 타입을 체크하는 방식이다.
  - 이 함수는 특정 타입을 확인하는 데 사용되며, 반환 타입은 `arg is Type` 형태의 타입 술어(Type Predicate)다.

  ```jsx
  interface Bird {
  fly: () => void;
  }

  interface Fish {
  swim: () => void;
  }

  function isFish(pet: Bird | Fish): pet is Fish {
  return (pet as Fish).swim !== undefined;
  }

  function move(pet: Bird | Fish) {
      // custom type guard
  if (isFish(pet)) {
      pet.swim();
  } else {
      pet.fly();
  }
  }
  ```

<br>

---

### 제네릭

제네릭은 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구다.

제네릭은 하나 이상 사용할 수도 있다. 일반적으로 T, U와 같은 형태로 많이 사용되는데 명시적으로 네이밍을 하는 것이 좋다.

```jsx
function identity<T>(arg: T): T {
  return arg;
}

let output1 = identity < string > 'myString';
let output2 = identity < number > 100;
```

<br>

---

### 인덱스 시그니처

인덱스 시그니처는 객체의 속성 이름과 값의 타입을 동적으로 지정할 수 있게 해주는 기능이다.

인덱스 시그니처는 객체가 어떤 타입의 키를 가지고, 그 키에 대응하는 값의 타입이 무엇인지를 정의할 때 사용된다.

```jsx
interface IDictionary {
  [key: string]: string;
}

const myDict: IDictionary = {
  firstKey: 'firstValue',
  secondKey: 'secondValue',
  // 이후 어떤 문자열 키에 대해서도 문자열 값을 가질 수 있음
};
```

<br>

- 하지만 키의 범위가 string[]으로 너무 커지기 때문에 존재하지 않은 키에 접근 시 undefined를 반환할 수도 있다.
  - 따라서 객체의 키는 동적으로 선언되는 경우를 최대한 지양하고, 객체의 타입도 필요에 따라 좁혀야 한다.

```jsx

// Record 사용
type TDictionary = Record<'firstKey' | 'secondeKey', string>

// 혹은 인덱스 시그니처
type TDictionary = {
	[key in 'firstKey' | 'secondeKey']: string
}

const myDict: IDictionary = {
  "firstKey": "firstValue",
  "secondKey": "secondValue"
};
```

<br>

