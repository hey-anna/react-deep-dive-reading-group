# 주한

### 리액트 개발을 위해 꼭 알아야 할 JavaScript

- 리액트 코드 기반이 되는 JavaScript
- 웹 애플리케이션이 작동하도록 리액트가 수행하는 작업을 이해하기 위해서는 JavaScript를 짚어볼 필요가 있다.

<br/>

---

### JavaScript의 동등 비교: 의존성 배열?

- 리액트에서 함수형 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열을 자주 보게 된다.

<br/>

---

### 의존성 배열

- `useEffect`, `useCallback`, `useMemo`와 같은 훅을 사용할 때 두 번째 인수로 전달되는 배열.
- 이 배열에는 특정 값들이 포함되며 해당 값들 변경될 때마다 해당 훅이 다시 실행되도록 설정하는 역할을 한다.

```jsx
useEffect(() => {
	console.log('의존성 요소 1 혹은 2가 바뀌었습니다.');
}, [의존성1, 의존성2]);
```

- 훅 실행 시점을 효율적으로 제어할 수 있도록 돕는다, 이를 올바르게 설정하지 않으면 불필요하게 훅이 반복 실행되거나 반대로 필요한 시점에 훅이 실행되지 않을 수도 있다.
  - 빈 배열: 훅이 한 번만 실행, 초기화 작업 혹은 한 번만 실행될 때 사용
  - 특정 값들 포함한 배열: 배열에 포함된 값들이 변경될 때만 훅이 다시 실행
  - 의존성 배열을 생략?: 매번 렌더링 될 때마다 훅이 실행, 권장되지 않는 방법이며 무한 루프나 성능 문제 생길 수 있음

<br/>

---

### 설정에 따라서

- eslint-react-config에 선언돼 있는 react-hooks/exhaustive-deps의 도움을 받아 해당 배열을 채울 수도 있다

<br/>

---

### ESLint와 eslint-plugin-react-hooks

- ESLint는 코드 스타일 문제 자동 감지, 개발자에게 개선 권장하는 도구.
- 리액트 프로젝트에서는 eslint-plugin-react-hooks 플러그인이 자주 사용되며 리액트 훅을 올바르게 사용했는지 확인해주는 규칙들을 제공한다.
- react-hooks/exhaustive-deps 규칙은 해당 플러그인에 포함된 규칙 중 하나고 hooks에서 의존성 배열을 정확하게 관리하도록 돕는다.
  - 의존성 누락 감지: 의존성 배열에 누락된 변수가 있다면 이를 감지하고 경고를 발생시킴
  - 자동 수정 제안: ESLint는 의존성 자동 감지 뿐 아니라 자동 추가 기능도 제공한다.
  - 어떤 값 포함해야 하는지 헷갈릴 수 있는데 이때 의존성을 추천 받을 수 있다.

```jsx
useEffect(() => {
  fetchData(someProp); // someProp 사용
}, []); // 이 배열이 빈 경우, someProp이 변경되더라도 useEffect는 실행되지 않는 게 맞다. 그러면 본문에서 파라미터는 왜 넣는 거지?
```

- someProp이 의존성 배열에 포함되지 않았다 → someProp이 변경되어도 useEffect는 실행되지 않는 문제가 발생할 수 있다
  - 해당 규칙이 이를 감지해서 경고를 띄우고 제안하는 걸 뜻함

<br/>

---

### 실제 react-hooks/exhaustive-deps 사용 케이스

- 한 번만 실행됐으면 좋겠다
  - 의존성 배열을 빈 배열로 설정
  - 컴포넌트 마운트 때만 실행, 이후에는 의존성 배열 변화가 없다, 재실행 X

```jsx
useEffect(() => {
  // 초기화 코드, 예를 들어 API 호출
  fetchInitialData();
}, []); // 빈 배열을 통해 최초 마운트 시에만 실행
```

- 규칙과 상호작용
  - 규칙은 useEffect 등 의존성 배열 가진 훅 내부에서 사용할 모든 변수를 의존성 배열에 포함시키도록 권장
  - 만약 위 코드에서 초기 데이터 호출 함수가 외부에서 정의되었고 의존성 배열에 포함되지 않았다면 경고 발생 가능

```jsx
const fetchInitialData = () => {
  // 데이터를 가져오는 함수
};

useEffect(() => {
  fetchInitialData(); // ESLint가 경고를 줄 수 있음
}, []);
```

- 규칙에 의해 함수를 의존성 배열에 추가하라 제안할 수 있다

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]); // 제안된 수정 사항
```

- 규칙을 무시해도 될 때 → ESLint 경고를 무시하면 됨
  - 굳이 규칙을 준수하지 않아도 된다면
  - 함수가 변경되더라도 useEffect가 다시 실행될 필요 없는 경우
  - 혹은 초기화 시 한 번만 실행되길 원한다면

```jsx
useEffect(() => {
  fetchInitialData(); // 초기화 작업
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---

### 함수도 의존성 배열에 포함될 수 있는 배경

- 리액트에서 컴포넌트는 함수형 컴포넌트로 작성되는 경우 많다
- 컴포넌트 안에서 함수들이 정의
- useEffect에서 함수들을 호출할 수 있음
  - 그런데 함수 자체도 의존성 배열에 포함될 수 있다

<br/>

---

### 리액트 훅과 함수 관계

- 리액트 컴포넌트는 상태(state)나 props 변경마다 리렌더링

> - 이 과정에서 컴포넌트 내 모든 함수도 재정의되기 때문
> - 리액트는 함수 참조가 변경될 수 있다 판단해서 의존성 배열에 포함시키도록 권장하기도 한다.

```jsx
const MyComponent = () => {
  const fetchInitialData = () => {
    // 데이터 가져오는 함수
  };

  useEffect(() => {
    fetchInitialData();
  }, []);
};
```
- 위 코드에서 사실 fetchInitialData 함수는 컴포넌트 리렌더링마다 새로 정의되는 것과 같음
- 따라서 규칙이 의존성 배열에 함수를 포함하라 경고를 줄 수 있음
  - 리액트 생각 1 : 컴포넌트가 리렌더링될텐데, 그럼 함수도 새로 쓰이는 거랑 다름 없어서 변경될 수 있잖아?
  - 리액트 생각 2: 그럼 의존성 배열에 포함시켜야 useEffect 같은 의존성 기반 훅이 잘 작동하겠네?

<br/>

---

### 함수가 의존성 배열에 포함될 때

- 함수를 의존성 배열에 포함시키는 것은 리액트가 해당 함수 참조 변경마다 useEffect를 재실행하게 만드는 방법

```jsx
useEffect(() => {
  fetchInitialData();
}, [fetchInitialData]);
```

- 위와 같은 코드에서는 함수 변경(== 리렌더링)마다 useEffect가 다시 실행

> - 리액트에서는 함수도 값과 마찬가지로 변경될 수 있는 상태로 간주, 이 경우를 대비해 의존성 배열에 포함시킨다.

<br/>

---

### 의도적으로 빈 배열을 사용해야 하는 경우

- 함수를 매번 재정의하더라도 useEffect를 한 번만 실행하고 싶다면 빈 배열 유지 혹은 useCallback을 사용해서 fetchInitialData를 메모이제이션(값을 캐시)할 수 있음.

```jsx
const fetchInitialData = useCallback(() => {
  // 데이터 가져오는 함수
}, []); // 의존성 배열이 빈 배열이므로, 함수가 재정의되지 않음

useEffect(() => {
  fetchInitialData();
}, []);
```

```jsx
useEffect(() => {
  fetchInitialData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

<br/>

---