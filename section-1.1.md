# Chapter 1: 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1 자바스크립트의 동등 비교
- 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 props의 동등 비교에 따른 결과다
- 리액트의 가상 DOM, 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

### 1.1.1 자바스크립트의 데이터 타입
**원시타입(primitive type)**
+ boolean
+ null
+ undefined
+ number
+ string
+ symbol
+ bigint

**객체타입(object/reference type)**
+ object

#### 1. 원시 타입
- 객체가 아닌 다른 모든 타입
##### undefined
- 선언됐지만 할당되지 않은 값
##### null
- 비어 있음을 나타내는 값
##### boolean
- false : false, 0, -0, NaN, 공백없는 빈문자열('',""), null, undefined
- true : 객체{}, 배열[]
\+ 객체와, 배열은 내부에 값이 존재하는지 여부와 상관없이 true로 취급
##### string
- '',"",``
- 백틱 = 템플릿 리터럴(template literal)
\+ 같은 문자열을 반환하지만 줄바꿈이 가능, 문자열 내부에 표현식을 쓸 수 있다.
##### symbol
- 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어 졌다.
? symbol.for : 동일한 값을 사용하기 위해 Symbol.for를 활용한다.

### 1.1.2 값을 저장하는 방식의 차이
- 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로, 원시값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.
\+ 27p 맨 하단 예시내용 참조
- 객체는 동일하게 선언했다 하더라도 저장하는 순간 다른 참조를 바라보기 때문에 false
\+ value의 값이 동일하게 가리키는 경우 true(28p 예시내용 참조)
: 객체간의 비교가 발생하는 경우, 내부의 값이 같더라도 결과가 true가 아닐 수 있음을 인지하기

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.js
- 동등 비교 ===가 가지는 한계를 극복학 위해 만들어 졌다. 그러나 여전히 객체 간 비교에 있어서는 자바스크립트의 특징으로 인해 ===와 동일하게 동작하는 것을 알 수 있다.
<details>
<summary>예시</summary>
-0 === +0 // true
Object.js(-0, +0) // false

Number.NaN === NaN // false
Object.js(Number.NaN, NaN) // true

NaN === 0 / 0 // false
Object.js(NaN, 0/ 0) true
</details>

### 1.1.4 리액트에서의 동등 비교
- 기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 얕은 비교로 충분하다. 만약 props에 또 다른 객체를 넘겨준다면 렌더링이 예상치 못하게 동작할 수 있다.

### 1.1.5 정리
- 자바스크립트의 객체비교불완전성은,, 자바스크립트을 기반으로 한 리액트의 함수형 프로그래밍 모델에서도 얕은 비교만을 사용해 비료를 수행해 필요한 기능을 구현하고 있다.
- 함수 컴포넌트에서 사용되는 훅의 의존성 배열의 비교, 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성, 렌더링 최적화를 위해서 꼭 필요한 React.memo를 올바르게 작동시키기 위해 고려해야할 것들을 쉽게 이해할 수 있을 것이다.
